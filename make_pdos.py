import ase
import ase.dft
import numpy as np
from matplotlib import pyplot as plt
from scipy.interpolate import RBFInterpolator as interpolator
from scipy.ndimage import gaussian_filter
from tqdm.auto import tqdm
import signac
from pymatgen.core.structure import Structure
from pymatgen.symmetry.analyzer import SpacegroupAnalyzer
import os
from scipy.spatial.distance import cdist
from update_radii import update

project = signac.get_project("./")
MAX_PHI = project.document["max_phi"]
MIN_PHI = project.document["min_phi"]


def get_epsilons(job):
    if job.document.has_gap:
        eps = list(
            reversed(
                sorted(
                    set([epsilon for f in job.document.has_gaps_at for epsilon in f])
                )
            )
        )
        eps.append(eps[-1] - 2)
        return eps
    else:
        return [16]


def tetrahedron_integration(
    num_points,
    num_bands,
    w_grid,
    w_min=0,
    w_max=None,
    num_bins=1000,
):
    """Tetrahedron integration method for computing density of states.

    Original code found at: https://github.com/boyuanliuoptics/DOS-calculation/

    The tetrahedron integration routine is based on:

    Improved tetrahedron method for Brillouin-zone integrations
    Peter E. Blöchl, O. Jepsen, and O. K. Andersen
    Phys. Rev. B 49, 16223 - Published 15 June 1994

    The inputs to this code are generated by the accompanying file
    ``band_solver.py``, which can be used as an example.

    Note that the variables in this function are named according to Python's
    zero-indexed convention, rather than the one-indexed convention used in
    the corresponding paper and MATLAB code.

    Parameters
    ----------
    num_points : tuple[int]
        A tuple of integers like ``(10, 10, 10)`` indicating the number of
        k-points in each dimension.
    w_grid : numpy.ndarray
        A NumPy array of frequencies for each k-point evaluated. The array
        must have shape ``(num_points[0], num_points[1], num_points[2],
        num_bands)``.
    w_min : float, optional
        Minimum frequency at which to compute the density of states (Default
        value = 0).
    w_max : float, optional
        Maximum frequency at which to compute the density of states. If None,
        the maximum frequency is 1.05 times the largest input frequency
        (Default value = None).
    num_bins : int, optional
        Number of bins to use in the density of states calculation (Default
        value = 1000).

    Returns
    -------
    w_bins : numpy.ndarray
        The frequencies at which the density of states was evaluated. The
        array has shape ``(num_bins,)``.
    DOS : numpy.ndarray
        The density of states corresponding to each evaluated frequency. The
        array has shape ``(num_bins,)``.

    """
    if w_max is None:
        w_max = 1.05 * np.max(w_grid)
    w_bins, w_step = np.linspace(w_min, w_max, num_bins, retstep=True)

    DOS = np.zeros_like(w_bins)
    parallelepiped = np.zeros(8)
    tetrahedra = np.zeros((6, 4))
    v_tetra = 1 / 6 / np.prod(num_points)

    def k_indices(num_points, num_bands):
        for nk1 in range(num_points[0] - 1):
            for nk2 in range(num_points[1] - 1):
                for nk3 in range(num_points[2] - 1):
                    for n_band in range(num_bands):
                        yield nk1, nk2, nk3, n_band

    total = np.prod(np.asarray(num_points) - 1) * num_bands
    pbar = tqdm(total=total, leave=False)
    for nk1, nk2, nk3, n_band in k_indices(num_points, num_bands):
        parallelepiped[0] = w_grid[nk1 + 1, nk2, nk3, n_band]
        parallelepiped[1] = w_grid[nk1 + 1, nk2 + 1, nk3, n_band]
        parallelepiped[2] = w_grid[nk1, nk2, nk3, n_band]
        parallelepiped[3] = w_grid[nk1, nk2 + 1, nk3, n_band]
        parallelepiped[4] = w_grid[nk1 + 1, nk2, nk3 + 1, n_band]
        parallelepiped[5] = w_grid[nk1 + 1, nk2 + 1, nk3 + 1, n_band]
        parallelepiped[6] = w_grid[nk1, nk2, nk3 + 1, n_band]
        parallelepiped[7] = w_grid[nk1, nk2 + 1, nk3 + 1, n_band]
        tetrahedra[:, [0, 3]] = [parallelepiped[2], parallelepiped[5]]
        tetrahedra[0, [1, 2]] = [parallelepiped[0], parallelepiped[1]]
        tetrahedra[1, [1, 2]] = [parallelepiped[1], parallelepiped[3]]
        tetrahedra[2, [1, 2]] = [parallelepiped[3], parallelepiped[7]]
        tetrahedra[3, [1, 2]] = [parallelepiped[6], parallelepiped[7]]
        tetrahedra[4, [1, 2]] = [parallelepiped[4], parallelepiped[6]]
        tetrahedra[5, [1, 2]] = [parallelepiped[0], parallelepiped[4]]

        for n_tetrahedron in range(6):
            w_corner = sorted(tetrahedra[n_tetrahedron])
            w10 = w_corner[1] - w_corner[0]
            w20 = w_corner[2] - w_corner[0]
            w30 = w_corner[3] - w_corner[0]
            w21 = w_corner[2] - w_corner[1]
            w31 = w_corner[3] - w_corner[1]
            w32 = w_corner[3] - w_corner[2]
            nw_min = round((w_corner[0] - w_min) / w_step)
            nw_max = round((w_corner[3] - w_min) / w_step)
            for nw in range(nw_min, nw_max):
                w_tmpt = w_bins[nw]
                if w30 == 0:
                    DOS[nw] += v_tetra / w_step
                    break
                elif w_tmpt < w_corner[0]:
                    # Zero contribution for w_tmpt < w_corner[0]
                    continue
                elif w_tmpt <= w_corner[1]:
                    if w10 > 0:
                        dos_tmpt = (
                            3
                            * v_tetra
                            * (w_tmpt - w_corner[0]) ** 2
                            / (w10 * w20 * w30)
                        )
                    elif w20 > 0:
                        dos_tmpt = 0
                    else:
                        dos_tmpt = 3 * 2 * v_tetra / w30
                elif w_tmpt <= w_corner[2]:
                    dos_tmpt = (
                        3
                        * v_tetra
                        / (w20 * w30)
                        * (
                            w10
                            + 2 * (w_tmpt - w_corner[1])
                            - (w20 + w31) * (w_tmpt - w_corner[1]) ** 2 / (w21 * w31)
                        )
                    )
                elif w_tmpt <= w_corner[3]:
                    dos_tmpt = (
                        3 * v_tetra * (w_tmpt - w_corner[3]) ** 2 / (w30 * w31 * w32)
                    )
                else:
                    # Zero contribution for w_tmpt > w_corner[3]
                    continue
                # Limit maximum DOS contribution for one tetrahedron
                dos_tmpt = min(dos_tmpt, v_tetra / w_step)
                DOS[nw] += dos_tmpt
        pbar.update(1)

    return w_bins, DOS


def setup_interpolators(mpb_output, lattice_vectors, basis):
    lines = [
        line.strip("\n").split(",")
        for line in list(open(mpb_output))
        if line.startswith("freqs")
    ]

    freqs = np.array(np.array(lines[1:])[:, 6:], dtype=float)
    kpoints = np.array(np.array(lines[1:])[:, 2:5], dtype=float)

    try:
        structure = Structure(
            lattice=lattice_vectors, species=np.ones(len(basis)), coords=basis
        )
        sg = SpacegroupAnalyzer(structure)
        symm_ops = sg.get_point_group_operations()
        rotations = np.array([m.rotation_matrix for m in symm_ops])
    except ValueError:
        # this is the case where the SpacegroupAnalyzer fails, falling back to spglib
        from spglib import get_symmetry

        rotations = []
        for i, r in enumerate(
            get_symmetry((lattice_vectors, basis, np.ones(len(basis))))["rotations"]
        ):
            if i == 0:
                rotations.append(r)
            elif np.linalg.norm(np.array(rotations) - r, axis=1).min() > 1e-4:
                rotations.append(r)
        rotations = np.array(rotations)

    # this code adds [±i, ±j, ±k], which will have equivalent frequencies
    for f, k in zip(freqs, kpoints.copy()):
        points = np.unique(np.dot(k, rotations), axis=0)
        dist = cdist(kpoints, points)
        for i in np.where(dist.min(axis=0) > 1e-6)[0]:
            kpoints = np.append(kpoints, points[i]).reshape(-1, 3)
            freqs = np.append(freqs, [f]).reshape(len(kpoints), -1)

    # set up a set of interpolators for the kpoint grid
    interpolators = []
    for f in freqs.T:
        if len(kpoints) > 10000:
            my_i = np.random.choice(np.arange(kpoints.shape[0]), 10000)
        else:
            my_i = np.arange(len(kpoints))
        interpolators.append(
            interpolator(kpoints[my_i], f.reshape(-1, 1)[my_i], smoothing=0.01)
        )

    return interpolators


def plot_mpb_output(
    mpb_output, ref_kpoints, kpoint_labels, lattice_vectors, basis, interpolation=10
):
    lines = [
        line.strip("\n").split(",")
        for line in list(open(mpb_output))
        if line.startswith("freqs")
    ]

    kpoints = np.array(np.array(lines[1:])[:, 2:5], dtype=float)
    interpolators = setup_interpolators(mpb_output, lattice_vectors, basis)

    new_kpoints = np.round(
        np.array(
            [
                ref_kpoints[0],
                *[
                    alpha * ref_kpoints[i] + (1 - alpha) * ref_kpoints[i - 1]
                    for i in range(1, len(ref_kpoints))
                    for alpha in np.linspace(0, 1, interpolation + 1)[1:]
                ],
            ]
        ),
        6,
    )

    xticks = np.array(list(range(len(new_kpoints))[::interpolation]))
    new_freqs = np.array([i(new_kpoints).flatten() for i in interpolators]).T

    mask = np.ones(len(new_freqs), dtype=bool)
    for i in reversed(range(len(new_kpoints))):
        if np.isnan(new_freqs[i][0]):
            mask[i] = False
            xticks[xticks >= i] -= 1

    cmap = plt.get_cmap("jet")
    for fi, f in enumerate(new_freqs.T):
        c = cmap(fi / (new_freqs.shape[1] + 1))
        plt.plot(f[mask], c=c)
        for k in kpoints:
            if np.linalg.norm(new_kpoints - k, axis=1).min() < 1e-6:
                i = np.where(np.linalg.norm(new_kpoints - k, axis=1) < 1e-6)[0][0]
                plt.scatter(i, f[i], marker=".", c=c)
        if fi > 0 and np.min(f) > np.max(new_freqs[:, fi - 1]):
            plt.fill_between(
                [0, len(new_kpoints)],
                np.max(new_freqs[:, fi - 1]),
                np.min(f),
                color="grey",
                alpha=0.2,
            )
            print(np.min(f), np.max(new_freqs[:, fi - 1]))

    plt.gca().set_xticks(xticks)
    GREEK_LETTERS = ["gamma", "sigma_0"]
    plt.gca().set_xticklabels(
        [
            r"${}$".format(k)
            if k.lower() not in GREEK_LETTERS
            else r"$\{}$".format(k.title())
            for k in kpoint_labels
        ]
    )
    plt.show()


def pdos_from_mpb(mpb_output, lattice_vectors, basis, ngrid=10):
    # read the MPB output for frequencies and kpoints
    interpolators = setup_interpolators(mpb_output, lattice_vectors, basis)
    num_bands = len(interpolators)

    # use the interpolators to make an evenly spaced grid for the
    # tetrahedral decomposition
    num_points = (ngrid, ngrid, ngrid)
    k_points = ase.dft.kpoints.monkhorst_pack(num_points)
    interp_freqs = np.array([i(k_points).flatten() for i in interpolators]).T
    reciprocal_vectors = np.array([[0, 1, 1], [1, 0, 1], [1, 1, 0]])
    diagonal_lengths = np.array(
        [
            np.linalg.norm(reciprocal_vectors @ [1, 1, 1]),
            np.linalg.norm(reciprocal_vectors @ [-1, 1, 1]),
            np.linalg.norm(reciprocal_vectors @ [1, -1, 1]),
            np.linalg.norm(reciprocal_vectors @ [1, 1, -1]),
        ]
    )
    min_diagonal_length = np.argmin(diagonal_lengths)
    w_grid = interp_freqs.reshape(num_points + (num_bands,))
    w_grid = np.flip(w_grid, axis=min_diagonal_length)
    w_bins_Tr, DOS_Tr = tetrahedron_integration(
        num_points, num_bands, w_grid, w_min=0, w_max=None, num_bins=20000
    )
    return w_bins_Tr, DOS_Tr


def make_pdos_entry(subjob, superjob, pdos_dict_raw):
    key = str((subjob.sp.radius, subjob.sp.dielectric))

    if key not in pdos_dict_raw:
        if (
            subjob.document.fill_fraction <= MIN_PHI
            or subjob.document.fill_fraction >= MAX_PHI
        ):
            return {}
        # return {}
        w, D = pdos_from_mpb(
            subjob.fn("output2.txt")
            if subjob.isfile("output2.txt")
            else subjob.fn("output.txt"),
            list(superjob.sp.lattice_vectors),
            list(superjob.sp.basis),
        )
        gD = gaussian_filter(D, np.nanmean(D))
        w = w.tolist()
        D = D.tolist()
        gD = gD.tolist()
    else:
        w, D, gD = pdos_dict_raw[key]

    return {key: np.asanyarray((w, D, gD), dtype=object)}


def make_pdos(superjob, epsilons=None):
    superjob_project = signac.get_project(path=superjob.fn(""))
    if epsilons is None:
        epsilons = get_epsilons(superjob)

    if not os.path.isdir(superjob.fn("pdos")):
        os.mkdir(superjob.fn("pdos"))

    for e in epsilons:
        pdos_name = f"pdos/epsilon={e}.npz"
        if superjob.isfile(pdos_name):
            pdos_dict_raw = dict(np.load(superjob.fn(pdos_name), allow_pickle=True))
        else:
            pdos_dict_raw = {}

        subjobs = list(
            sorted(
                list(superjob_project.find_jobs({"dielectric": e})),
                key=lambda job: job.sp.radius,
            )
        )

        radii = np.array([job.sp.radius for job in subjobs])
        ff = np.array([job.document.get("fill_fraction", np.nan) for job in subjobs])

        if e == 16:
            update(superjob)

        print(
            "\t\t-->{} to go".format(
                len([r for r in radii if str((r, e)) not in pdos_dict_raw])
            )
        )
        w_bins_Tr = None
        DOS_Tr = None
        gDOS = None

        try:
            for subjob in tqdm(subjobs):
                if "fill_fraction" in subjob.document:
                    i = np.where(radii == subjob.sp.radius)[0][0]
                    new_entry = make_pdos_entry(subjob, superjob, pdos_dict_raw)
                    if len(list(new_entry.keys())) > 0:
                        pdos_dict_raw = {**pdos_dict_raw, **new_entry}
                        w, D, gD = list(new_entry.values())[0]
                        if w_bins_Tr is None:
                            w_bins_Tr = np.zeros((len(radii), len(w)))
                            DOS_Tr = np.zeros((len(radii), len(D)))
                            gDOS = np.zeros((len(radii), len(gD)))
                        w_bins_Tr[i], DOS_Tr[i], gDOS[i] = w, D, gD

            np.savez(superjob.fn(pdos_name), **pdos_dict_raw)

            # fig = plt.figure()
            # timer = fig.canvas.new_timer(interval=30000)
            # timer.add_callback(plt.close)

            # for r, w, gD, f in zip(radii, w_bins_Tr, gDOS, ff):
            #     plt.plot(w, gD + r, c=plt.get_cmap("jet")(f), zorder=-r)

            # timer.start()
            # plt.show()

            # gDOS_copy = gDOS.copy()
            # gDOS_copy[gDOS_copy == 0] = np.nan

            # fig = plt.figure()
            # timer = fig.canvas.new_timer(interval=30000)
            # timer.add_callback(plt.close)

            # plt.imshow(np.flipud(gDOS_copy), aspect="auto", vmax=100)
            # plt.xticks([])
            # plt.yticks([])
            # plt.xlabel("$\\omega/\\omega_{max}$")
            # plt.ylabel("$\\phi$")

            # timer.start()
            # plt.show()\
        except KeyboardInterrupt:
            np.savez(superjob.fn(pdos_name), **pdos_dict_raw)
            break


if __name__ == "__main__":
    import signac
    import argparse

    parser = argparse.ArgumentParser(description="Process some integers.")
    parser.add_argument("-j", "--job_id", type=str, help="The ID of the job")
    parser.add_argument("-r", "--radius", type=float, help="The radius")
    parser.add_argument("-e", "--epsilon", type=int, help="The dielectric constant")
    parser.add_argument("--pdos", action="store_true", default=False)
    parser.add_argument("--spectra", action="store_true", default=False)
    parser.add_argument("--recalc", action="store_true", default=False)
    parser.add_argument(
        "-sj",
        "--subjob_id",
        type=str,
        help="The ID of the subjob, overrides entries for radius and epsilon",
    )

    args = parser.parse_args()

    job = signac.get_project().open_job(id=args.job_id)

    if args.subjob_id is not None:
        subjob = signac.get_project(path=job.fn("")).open_job(id=args.subjob_id)
        radius = subjob.sp.radius
        epsilon = subjob.sp.dielectric
    elif args.radius is not None:
        radius = args.radius
        epsilon = int(args.epsilon)
        subjob = (
            signac.get_project(path=job.fn(""))
            .open_job({"radius": radius, "dielectric": epsilon})
            .init()
        )

    pdos_name = f"pdos/epsilon={epsilon}.npz"

    if job.isfile(pdos_name):
        pdos_dict_raw = dict(np.load(job.fn(pdos_name), allow_pickle=True))
    else:
        pdos_dict_raw = {}

    print(subjob.document.fill_fraction * 16 + (1 - subjob.document.fill_fraction))

    assert (args.pdos is True) or (args.spectra is True) or (args.recalc is True)

    if args.recalc:
        if str((radius, epsilon)) in pdos_dict_raw:
            _ = pdos_dict_raw.pop(str((radius, epsilon)))
        entry = make_pdos_entry(subjob, job, pdos_dict_raw)
        pdos_dict_raw = {**pdos_dict_raw, **entry}
        np.savez(job.fn(pdos_name), **pdos_dict_raw)
        w, D, gD = list(entry.values())[0]

        plt.plot(w, D)
        plt.plot(w, gD)
        plt.show()

    if args.pdos:
        entry = make_pdos_entry(subjob, job, pdos_dict_raw)
        w, D, gD = list(entry.values())[0]

        plt.plot(w, D)
        plt.plot(w, gD)
        plt.show()

    if args.spectra:
        output_file = (
            subjob.fn("output2.txt")
            if subjob.isfile("output2.txt")
            else subjob.fn("output.txt")
        )
        plot_mpb_output(
            output_file,
            job.document.kpoints,
            job.document.kp_labels,
            job.sp.lattice_vectors,
            job.sp.basis,
        )
