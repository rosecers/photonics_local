import ase
import ase.dft
import numpy as np
from matplotlib import pyplot as plt
from scipy.interpolate import LinearNDInterpolator as interpolator
from scipy.ndimage import gaussian_filter
from tqdm.auto import tqdm
import signac

project = signac.get_project("/Users/rca/periodic_structures/")
MAX_PHI = project.document['max_phi']
MIN_PHI = project.document['min_phi']

def close_event():
    plt.close() #timer calls this function after 3 seconds and closes the window 

def tetrahedron_integration(
    num_points,
    num_bands,
    w_grid,
    w_min=0,
    w_max=None,
    num_bins=1000,
):
    """Tetrahedron integration method for computing density of states.

    Original code found at: https://github.com/boyuanliuoptics/DOS-calculation/

    The tetrahedron integration routine is based on:

    Improved tetrahedron method for Brillouin-zone integrations
    Peter E. Blöchl, O. Jepsen, and O. K. Andersen
    Phys. Rev. B 49, 16223 - Published 15 June 1994

    The inputs to this code are generated by the accompanying file
    ``band_solver.py``, which can be used as an example.

    Note that the variables in this function are named according to Python's
    zero-indexed convention, rather than the one-indexed convention used in
    the corresponding paper and MATLAB code.

    Parameters
    ----------
    num_points : tuple[int]
        A tuple of integers like ``(10, 10, 10)`` indicating the number of
        k-points in each dimension.
    w_grid : numpy.ndarray
        A NumPy array of frequencies for each k-point evaluated. The array
        must have shape ``(num_points[0], num_points[1], num_points[2],
        num_bands)``.
    w_min : float, optional
        Minimum frequency at which to compute the density of states (Default
        value = 0).
    w_max : float, optional
        Maximum frequency at which to compute the density of states. If None,
        the maximum frequency is 1.05 times the largest input frequency
        (Default value = None).
    num_bins : int, optional
        Number of bins to use in the density of states calculation (Default
        value = 1000).

    Returns
    -------
    w_bins : numpy.ndarray
        The frequencies at which the density of states was evaluated. The
        array has shape ``(num_bins,)``.
    DOS : numpy.ndarray
        The density of states corresponding to each evaluated frequency. The
        array has shape ``(num_bins,)``.

    """
    if w_max is None:
        w_max = 1.05 * np.max(w_grid)
    w_bins, w_step = np.linspace(w_min, w_max, num_bins, retstep=True)

    DOS = np.zeros_like(w_bins)
    parallelepiped = np.zeros(8)
    tetrahedra = np.zeros((6, 4))
    v_tetra = 1 / 6 / np.prod(num_points)

    def k_indices(num_points, num_bands):
        for nk1 in range(num_points[0] - 1):
            for nk2 in range(num_points[1] - 1):
                for nk3 in range(num_points[2] - 1):
                    for n_band in range(num_bands):
                        yield nk1, nk2, nk3, n_band

    total = np.prod(np.asarray(num_points) - 1) * num_bands
    pbar = tqdm(total=total, leave=False)
    for nk1, nk2, nk3, n_band in k_indices(num_points, num_bands):
        parallelepiped[0] = w_grid[nk1 + 1, nk2, nk3, n_band]
        parallelepiped[1] = w_grid[nk1 + 1, nk2 + 1, nk3, n_band]
        parallelepiped[2] = w_grid[nk1, nk2, nk3, n_band]
        parallelepiped[3] = w_grid[nk1, nk2 + 1, nk3, n_band]
        parallelepiped[4] = w_grid[nk1 + 1, nk2, nk3 + 1, n_band]
        parallelepiped[5] = w_grid[nk1 + 1, nk2 + 1, nk3 + 1, n_band]
        parallelepiped[6] = w_grid[nk1, nk2, nk3 + 1, n_band]
        parallelepiped[7] = w_grid[nk1, nk2 + 1, nk3 + 1, n_band]
        tetrahedra[:, [0, 3]] = [parallelepiped[2], parallelepiped[5]]
        tetrahedra[0, [1, 2]] = [parallelepiped[0], parallelepiped[1]]
        tetrahedra[1, [1, 2]] = [parallelepiped[1], parallelepiped[3]]
        tetrahedra[2, [1, 2]] = [parallelepiped[3], parallelepiped[7]]
        tetrahedra[3, [1, 2]] = [parallelepiped[6], parallelepiped[7]]
        tetrahedra[4, [1, 2]] = [parallelepiped[4], parallelepiped[6]]
        tetrahedra[5, [1, 2]] = [parallelepiped[0], parallelepiped[4]]

        for n_tetrahedron in range(6):
            w_corner = sorted(tetrahedra[n_tetrahedron])
            w10 = w_corner[1] - w_corner[0]
            w20 = w_corner[2] - w_corner[0]
            w30 = w_corner[3] - w_corner[0]
            w21 = w_corner[2] - w_corner[1]
            w31 = w_corner[3] - w_corner[1]
            w32 = w_corner[3] - w_corner[2]
            nw_min = round((w_corner[0] - w_min) / w_step)
            nw_max = round((w_corner[3] - w_min) / w_step)
            for nw in range(nw_min, nw_max):
                w_tmpt = w_bins[nw]
                if w30 == 0:
                    DOS[nw] += v_tetra / w_step
                    break
                elif w_tmpt < w_corner[0]:
                    # Zero contribution for w_tmpt < w_corner[0]
                    continue
                elif w_tmpt <= w_corner[1]:
                    if w10 > 0:
                        dos_tmpt = (
                            3
                            * v_tetra
                            * (w_tmpt - w_corner[0]) ** 2
                            / (w10 * w20 * w30)
                        )
                    elif w20 > 0:
                        dos_tmpt = 0
                    else:
                        dos_tmpt = 3 * 2 * v_tetra / w30
                elif w_tmpt <= w_corner[2]:
                    dos_tmpt = (
                        3
                        * v_tetra
                        / (w20 * w30)
                        * (
                            w10
                            + 2 * (w_tmpt - w_corner[1])
                            - (w20 + w31) * (w_tmpt - w_corner[1]) ** 2 / (w21 * w31)
                        )
                    )
                elif w_tmpt <= w_corner[3]:
                    dos_tmpt = (
                        3 * v_tetra * (w_tmpt - w_corner[3]) ** 2 / (w30 * w31 * w32)
                    )
                else:
                    # Zero contribution for w_tmpt > w_corner[3]
                    continue
                # Limit maximum DOS contribution for one tetrahedron
                dos_tmpt = min(dos_tmpt, v_tetra / w_step)
                DOS[nw] += dos_tmpt
        pbar.update(1)

    return w_bins, DOS


def pdos_from_mpb(mpb_output, new_kp, ngrid=10):
    # read the MPB output for frequencies and kpoints
    lines = [
        line.strip("\n").split(",")
        for line in list(open(mpb_output))
        if line.startswith("freqs")
    ]

    freqs = np.array(np.array(lines[1:])[:, 6:], dtype=float)
    num_bands = freqs.shape[1]
    kpoints = np.array(np.array(lines[1:])[:, 2:5], dtype=float)

    # this code adds [±i, ±j, ±k], which will have equivalent frequencies
    for f, k in zip(freqs, kpoints.copy()):
        for r in [-1, 1]:
            for s in [-1, 1]:
                for t in [-1, 1]:
                    if r < 0 or s < 0 or t < 0:  # skip [i, j, k]
                        kM = np.array([k[0] * r, k[1] * s, k[2] * t])

                        # skip any points already in kpoint set
                        if np.linalg.norm(kpoints - kM, axis=1).min() > 1e-6:
                            kpoints = np.append(kpoints, [kM]).reshape(-1, 3)
                            freqs = np.append(freqs, [f]).reshape(len(kpoints), -1)

    # set up a set of interpolators for the kpoint grid
    interpolators = []
    for f in freqs.T:
        interpolators.append(interpolator(kpoints, f.reshape(-1, 1)))

    # use the interpolators to make an evenly spaced grid for the
    # tetrahedral decomposition
    num_points = (ngrid, ngrid, ngrid)
    k_points = ase.dft.kpoints.monkhorst_pack(num_points)
    interp_freqs = np.array([i(k_points).flatten() for i in interpolators]).T
    reciprocal_vectors = np.array([[0, 1, 1], [1, 0, 1], [1, 1, 0]])
    diagonal_lengths = np.array(
        [
            np.linalg.norm(reciprocal_vectors @ [1, 1, 1]),
            np.linalg.norm(reciprocal_vectors @ [-1, 1, 1]),
            np.linalg.norm(reciprocal_vectors @ [1, -1, 1]),
            np.linalg.norm(reciprocal_vectors @ [1, 1, -1]),
        ]
    )
    min_diagonal_length = np.argmin(diagonal_lengths)
    w_grid = interp_freqs.reshape(num_points + (num_bands,))
    w_grid = np.flip(w_grid, axis=min_diagonal_length)
    w_bins_Tr, DOS_Tr = tetrahedron_integration(
        num_points, num_bands, w_grid, w_min=0, w_max=None, num_bins=20000
    )
    return w_bins_Tr, DOS_Tr


def make_pdos_entry(subjob, superjob, pdos_dict_raw):
    
    key = str((subjob.sp.radius, subjob.sp.dielectric))

    if key not in pdos_dict_raw:
        if subjob.document.fill_fraction<=MIN_PHI or subjob.document.fill_fraction>=MAX_PHI:
            return {}
        # return {}
        w, D = pdos_from_mpb(
            subjob.fn("output2.txt")
            if subjob.isfile("output2.txt")
            else subjob.fn("output.txt"),
            superjob.document.kpoints,
        )
        gD = gaussian_filter(D, np.nanmean(D))
        w = w.tolist()
        D = D.tolist()
        gD = gD.tolist()
    else:
        w, D, gD = pdos_dict_raw[key]

    return {key: np.asanyarray((w, D, gD), dtype=object)}


def make_pdos(superjob):
    superjob_project = signac.get_project(path=superjob.fn(""))

    if superjob.isfile('pdos.npz'):
        pdos_dict_raw = dict(np.load(superjob.fn("pdos.npz"), allow_pickle=True))
    else:
        pdos_dict_raw = {}

    subjobs = list(
        sorted(
            list(superjob_project.find_jobs({"dielectric": 16})),
            key=lambda job: job.sp.radius,
        )
    )

    radii = np.array([job.sp.radius for job in subjobs])
    ff = np.array([job.document.fill_fraction for job in subjobs])

    if len(superjob.document.fill_fraction) != len(ff):
        inp = input(
            "Overwrite ff & radius? {}->{}".format(
                len(superjob.document.fill_fraction), len(ff)
            )
        ).upper()
        if inp == "Y":
            superjob.document.fill_fraction = ff
            superjob.document.radii = radii

    w_bins_Tr = None
    DOS_Tr = None
    gDOS = None

    try:
        for subjob in tqdm(subjobs):
            i = np.where(radii == subjob.sp.radius)[0][0]
            new_entry = make_pdos_entry(subjob, superjob, pdos_dict_raw)
            if len(list(new_entry.keys()))>0:
                pdos_dict_raw = {**pdos_dict_raw, **new_entry}
                w, D, gD = list(new_entry.values())[0]
                if w_bins_Tr is None:
                    w_bins_Tr = np.zeros((len(radii), len(w)))
                    DOS_Tr = np.zeros((len(radii), len(D)))
                    gDOS = np.zeros((len(radii), len(gD)))
                w_bins_Tr[i], DOS_Tr[i], gDOS[i] = w, D, gD

        np.savez(superjob.fn("pdos.npz"), **pdos_dict_raw)

        fig = plt.figure()
        timer = fig.canvas.new_timer(interval = 30000) 
        timer.add_callback(plt.close)

        for r, w, gD, f in zip(radii, w_bins_Tr, gDOS, ff):
            plt.plot(w, gD + r, c=plt.get_cmap("jet")(f), zorder=-r)

        timer.start()
        plt.show()

        gDOS_copy = gDOS.copy()
        gDOS_copy[gDOS_copy == 0] = np.nan

        fig = plt.figure()
        timer = fig.canvas.new_timer(interval = 30000)
        timer.add_callback(plt.close)

        plt.imshow(np.flipud(gDOS_copy), aspect="auto", vmax=100)
        plt.xticks([])
        plt.yticks([])
        plt.xlabel("$\\omega/\\omega_{max}$")
        plt.ylabel("$\\phi$")

        timer.start()
        plt.show()

        for subjob in tqdm(list(superjob_project.find_jobs())):
            pdos_dict_raw = {**pdos_dict_raw, **make_pdos_entry(subjob, superjob, pdos_dict_raw)}

    except KeyboardInterrupt:
        pass

    np.savez(superjob.fn("pdos.npz"), **pdos_dict_raw)


if __name__ == "__main__":
    import sys


    if len(sys.argv) == 1:
        ojob = [
            job
            for job in list(project.find_jobs({"doc.kpoints.$exists": True}))
            if not job.isfile("pdos.npz")
        ][0]
    else:
        ojob = project.open_job(id=sys.argv[1])

    make_pdos(ojob)