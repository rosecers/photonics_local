import ase
import ase.dft
import numpy as np
from matplotlib import pyplot as plt
from scipy.interpolate import RBFInterpolator as interpolator
from scipy.ndimage import gaussian_filter
from tqdm.auto import tqdm
import signac
from pymatgen.core.structure import Structure
from pymatgen.symmetry.analyzer import SpacegroupAnalyzer
import os

project = signac.get_project("/Users/rca/periodic_structures/")
MAX_PHI = project.document["max_phi"]
MIN_PHI = project.document["min_phi"]


def get_epsilons(job):
    if job.document.has_gap:
        eps = list(
            reversed(
                sorted(
                    set([epsilon for f in job.document.has_gaps_at for epsilon in f])
                )
            )
        )
        eps.append(eps[-1] - 2)
        return eps
    else:
        return [16]


def tetrahedron_integration(
    num_points,
    num_bands,
    w_grid,
    w_min=0,
    w_max=None,
    num_bins=1000,
):
    """Tetrahedron integration method for computing density of states.

    Original code found at: https://github.com/boyuanliuoptics/DOS-calculation/

    The tetrahedron integration routine is based on:

    Improved tetrahedron method for Brillouin-zone integrations
    Peter E. Blöchl, O. Jepsen, and O. K. Andersen
    Phys. Rev. B 49, 16223 - Published 15 June 1994

    The inputs to this code are generated by the accompanying file
    ``band_solver.py``, which can be used as an example.

    Note that the variables in this function are named according to Python's
    zero-indexed convention, rather than the one-indexed convention used in
    the corresponding paper and MATLAB code.

    Parameters
    ----------
    num_points : tuple[int]
        A tuple of integers like ``(10, 10, 10)`` indicating the number of
        k-points in each dimension.
    w_grid : numpy.ndarray
        A NumPy array of frequencies for each k-point evaluated. The array
        must have shape ``(num_points[0], num_points[1], num_points[2],
        num_bands)``.
    w_min : float, optional
        Minimum frequency at which to compute the density of states (Default
        value = 0).
    w_max : float, optional
        Maximum frequency at which to compute the density of states. If None,
        the maximum frequency is 1.05 times the largest input frequency
        (Default value = None).
    num_bins : int, optional
        Number of bins to use in the density of states calculation (Default
        value = 1000).

    Returns
    -------
    w_bins : numpy.ndarray
        The frequencies at which the density of states was evaluated. The
        array has shape ``(num_bins,)``.
    DOS : numpy.ndarray
        The density of states corresponding to each evaluated frequency. The
        array has shape ``(num_bins,)``.

    """
    if w_max is None:
        w_max = 1.05 * np.max(w_grid)
    w_bins, w_step = np.linspace(w_min, w_max, num_bins, retstep=True)

    DOS = np.zeros_like(w_bins)
    parallelepiped = np.zeros(8)
    tetrahedra = np.zeros((6, 4))
    v_tetra = 1 / 6 / np.prod(num_points)

    def k_indices(num_points, num_bands):
        for nk1 in range(num_points[0] - 1):
            for nk2 in range(num_points[1] - 1):
                for nk3 in range(num_points[2] - 1):
                    for n_band in range(num_bands):
                        yield nk1, nk2, nk3, n_band

    total = np.prod(np.asarray(num_points) - 1) * num_bands
    pbar = tqdm(total=total, leave=False)
    for nk1, nk2, nk3, n_band in k_indices(num_points, num_bands):
        parallelepiped[0] = w_grid[nk1 + 1, nk2, nk3, n_band]
        parallelepiped[1] = w_grid[nk1 + 1, nk2 + 1, nk3, n_band]
        parallelepiped[2] = w_grid[nk1, nk2, nk3, n_band]
        parallelepiped[3] = w_grid[nk1, nk2 + 1, nk3, n_band]
        parallelepiped[4] = w_grid[nk1 + 1, nk2, nk3 + 1, n_band]
        parallelepiped[5] = w_grid[nk1 + 1, nk2 + 1, nk3 + 1, n_band]
        parallelepiped[6] = w_grid[nk1, nk2, nk3 + 1, n_band]
        parallelepiped[7] = w_grid[nk1, nk2 + 1, nk3 + 1, n_band]
        tetrahedra[:, [0, 3]] = [parallelepiped[2], parallelepiped[5]]
        tetrahedra[0, [1, 2]] = [parallelepiped[0], parallelepiped[1]]
        tetrahedra[1, [1, 2]] = [parallelepiped[1], parallelepiped[3]]
        tetrahedra[2, [1, 2]] = [parallelepiped[3], parallelepiped[7]]
        tetrahedra[3, [1, 2]] = [parallelepiped[6], parallelepiped[7]]
        tetrahedra[4, [1, 2]] = [parallelepiped[4], parallelepiped[6]]
        tetrahedra[5, [1, 2]] = [parallelepiped[0], parallelepiped[4]]

        for n_tetrahedron in range(6):
            w_corner = sorted(tetrahedra[n_tetrahedron])
            w10 = w_corner[1] - w_corner[0]
            w20 = w_corner[2] - w_corner[0]
            w30 = w_corner[3] - w_corner[0]
            w21 = w_corner[2] - w_corner[1]
            w31 = w_corner[3] - w_corner[1]
            w32 = w_corner[3] - w_corner[2]
            nw_min = round((w_corner[0] - w_min) / w_step)
            nw_max = round((w_corner[3] - w_min) / w_step)
            for nw in range(nw_min, nw_max):
                w_tmpt = w_bins[nw]
                if w30 == 0:
                    DOS[nw] += v_tetra / w_step
                    break
                elif w_tmpt < w_corner[0]:
                    # Zero contribution for w_tmpt < w_corner[0]
                    continue
                elif w_tmpt <= w_corner[1]:
                    if w10 > 0:
                        dos_tmpt = (
                            3
                            * v_tetra
                            * (w_tmpt - w_corner[0]) ** 2
                            / (w10 * w20 * w30)
                        )
                    elif w20 > 0:
                        dos_tmpt = 0
                    else:
                        dos_tmpt = 3 * 2 * v_tetra / w30
                elif w_tmpt <= w_corner[2]:
                    dos_tmpt = (
                        3
                        * v_tetra
                        / (w20 * w30)
                        * (
                            w10
                            + 2 * (w_tmpt - w_corner[1])
                            - (w20 + w31) * (w_tmpt - w_corner[1]) ** 2 / (w21 * w31)
                        )
                    )
                elif w_tmpt <= w_corner[3]:
                    dos_tmpt = (
                        3 * v_tetra * (w_tmpt - w_corner[3]) ** 2 / (w30 * w31 * w32)
                    )
                else:
                    # Zero contribution for w_tmpt > w_corner[3]
                    continue
                # Limit maximum DOS contribution for one tetrahedron
                dos_tmpt = min(dos_tmpt, v_tetra / w_step)
                DOS[nw] += dos_tmpt
        pbar.update(1)

    return w_bins, DOS


def setup_interpolators(mpb_output, lattice_vectors, basis):
    lines = [
        line.strip("\n").split(",")
        for line in list(open(mpb_output))
        if line.startswith("freqs")
    ]

    freqs = np.array(np.array(lines[1:])[:, 6:], dtype=float)
    kpoints = np.array(np.array(lines[1:])[:, 2:5], dtype=float)

    structure = Structure(
        lattice=lattice_vectors, species=np.ones(len(basis)), coords=basis
    )
    sg = SpacegroupAnalyzer(structure)
    symm_ops = sg.get_point_group_operations()

    # this code adds [±i, ±j, ±k], which will have equivalent frequencies
    for f, k in zip(freqs, kpoints.copy()):
        points = np.dot(k, [m.rotation_matrix for m in symm_ops])
        rm_list = []
        # identify and remove duplicates from the list of equivalent k-points:
        for i in range(len(points) - 1):
            if np.linalg.norm(kpoints - points[i], axis=1).min() < 1e-6:
                rm_list.append(i)

        for p in np.delete(points, rm_list, axis=0):
            kpoints = np.append(kpoints, [p]).reshape(-1, 3)
            freqs = np.append(freqs, [f]).reshape(len(kpoints), -1)

    # set up a set of interpolators for the kpoint grid
    interpolators = []
    for f in freqs.T:
        interpolators.append(interpolator(kpoints, f.reshape(-1, 1), smoothing=0.01))

    return interpolators


def plot_mpb_output(
    mpb_output, ref_kpoints, kpoint_labels, lattice_vectors, basis, interpolation=10
):
    lines = [
        line.strip("\n").split(",")
        for line in list(open(mpb_output))
        if line.startswith("freqs")
    ]

    freqs = np.array(np.array(lines[1:])[:, 6:], dtype=float)
    kpoints = np.array(np.array(lines[1:])[:, 2:5], dtype=float)
    interpolators = setup_interpolators(mpb_output, lattice_vectors, basis)

    new_kpoints = np.round(
        np.array(
            [
                ref_kpoints[0],
                *[
                    alpha * ref_kpoints[i] + (1 - alpha) * ref_kpoints[i - 1]
                    for i in range(1, len(ref_kpoints))
                    for alpha in np.linspace(0, 1, interpolation + 1)[1:]
                ],
            ]
        ),
        6,
    )

    xticks = np.array(list(range(len(new_kpoints))[::interpolation]))
    new_freqs = np.array([i(new_kpoints).flatten() for i in interpolators]).T

    mask = np.ones(len(new_freqs), dtype=bool)
    for i in reversed(range(len(new_kpoints))):
        if np.isnan(new_freqs[i][0]):
            mask[i] = False
            xticks[xticks >= i] -= 1

    cmap = plt.get_cmap("jet")
    for fi, f in enumerate(new_freqs.T):
        c = cmap(fi / (new_freqs.shape[1] + 1))
        plt.plot(f[mask], c=c)
        for k in kpoints:
            if np.linalg.norm(new_kpoints - k, axis=1).min() < 1e-6:
                i = np.where(np.linalg.norm(new_kpoints - k, axis=1) < 1e-6)[0][0]
                plt.scatter(i, f[i], marker=".", c=c)
        if fi > 0 and np.min(f) > np.max(new_freqs[:, fi - 1]):
            plt.fill_between(
                [0, len(new_kpoints)],
                np.max(new_freqs[:, fi - 1]),
                np.min(f),
                color="grey",
                alpha=0.2,
            )
            print(np.min(f), np.max(new_freqs[:, fi - 1]))

    plt.gca().set_xticks(xticks)
    GREEK_LETTERS = ["gamma", "sigma_0"]
    plt.gca().set_xticklabels(
        [
            r"${}$".format(k)
            if k.lower() not in GREEK_LETTERS
            else r"$\{}$".format(k.title())
            for k in kpoint_labels
        ]
    )
    plt.show()


def pdos_from_mpb(mpb_output, lattice_vectors, basis, ngrid=10):
    # read the MPB output for frequencies and kpoints
    interpolators = setup_interpolators(mpb_output, lattice_vectors, basis)
    num_bands = len(interpolators)

    # use the interpolators to make an evenly spaced grid for the
    # tetrahedral decomposition
    num_points = (ngrid, ngrid, ngrid)
    k_points = ase.dft.kpoints.monkhorst_pack(num_points)
    interp_freqs = np.array([i(k_points).flatten() for i in interpolators]).T
    reciprocal_vectors = np.array([[0, 1, 1], [1, 0, 1], [1, 1, 0]])
    diagonal_lengths = np.array(
        [
            np.linalg.norm(reciprocal_vectors @ [1, 1, 1]),
            np.linalg.norm(reciprocal_vectors @ [-1, 1, 1]),
            np.linalg.norm(reciprocal_vectors @ [1, -1, 1]),
            np.linalg.norm(reciprocal_vectors @ [1, 1, -1]),
        ]
    )
    min_diagonal_length = np.argmin(diagonal_lengths)
    w_grid = interp_freqs.reshape(num_points + (num_bands,))
    w_grid = np.flip(w_grid, axis=min_diagonal_length)
    w_bins_Tr, DOS_Tr = tetrahedron_integration(
        num_points, num_bands, w_grid, w_min=0, w_max=None, num_bins=20000
    )
    return w_bins_Tr, DOS_Tr


def make_pdos_entry(subjob, superjob, pdos_dict_raw):
    key = str((subjob.sp.radius, subjob.sp.dielectric))

    if key not in pdos_dict_raw:
        if (
            subjob.document.fill_fraction <= MIN_PHI
            or subjob.document.fill_fraction >= MAX_PHI
        ):
            return {}
        # return {}
        w, D = pdos_from_mpb(
            subjob.fn("output2.txt")
            if subjob.isfile("output2.txt")
            else subjob.fn("output.txt"),
            list(superjob.sp.lattice_vectors),
            list(superjob.sp.basis),
        )
        gD = gaussian_filter(D, np.nanmean(D))
        w = w.tolist()
        D = D.tolist()
        gD = gD.tolist()
    else:
        w, D, gD = pdos_dict_raw[key]

    return {key: np.asanyarray((w, D, gD), dtype=object)}


def make_pdos(superjob):
    superjob_project = signac.get_project(path=superjob.fn(""))
    epsilons = get_epsilons(superjob)

    if not os.path.isdir(superjob.fn("pdos")):
        os.mkdir(superjob.fn("pdos"))

    for e in epsilons:
        pdos_name = f"pdos/epsilon={e}.npz"
        if superjob.isfile(pdos_name):
            pdos_dict_raw = dict(np.load(superjob.fn(pdos_name), allow_pickle=True))
        else:
            pdos_dict_raw = {}

        subjobs = list(
            sorted(
                list(superjob_project.find_jobs({"dielectric": e})),
                key=lambda job: job.sp.radius,
            )
        )

        radii = np.array([job.sp.radius for job in subjobs])
        ff = np.array([job.document.fill_fraction for job in subjobs])

        if e==16 and len(superjob.document.fill_fraction) != len(ff):
            # inp = input(
            #     "Overwrite ff & radius? {}->{}".format(
            #         len(superjob.document.fill_fraction), len(ff)
            #     )
            # ).upper()
            # if inp == "Y":
            print(
                "Overwriting for {}, {}->{}".format(
                    superjob, len(superjob.document.fill_fraction), len(ff)
                )
            )
            superjob.document.fill_fraction = ff
            superjob.document.radii = radii

        w_bins_Tr = None
        DOS_Tr = None
        gDOS = None

        try:
            for subjob in tqdm(subjobs):
                i = np.where(radii == subjob.sp.radius)[0][0]
                new_entry = make_pdos_entry(subjob, superjob, pdos_dict_raw)
                if len(list(new_entry.keys())) > 0:
                    pdos_dict_raw = {**pdos_dict_raw, **new_entry}
                    w, D, gD = list(new_entry.values())[0]
                    if w_bins_Tr is None:
                        w_bins_Tr = np.zeros((len(radii), len(w)))
                        DOS_Tr = np.zeros((len(radii), len(D)))
                        gDOS = np.zeros((len(radii), len(gD)))
                    w_bins_Tr[i], DOS_Tr[i], gDOS[i] = w, D, gD

            np.savez(superjob.fn(pdos_name), **pdos_dict_raw)

            # fig = plt.figure()
            # timer = fig.canvas.new_timer(interval=30000)
            # timer.add_callback(plt.close)

            # for r, w, gD, f in zip(radii, w_bins_Tr, gDOS, ff):
            #     plt.plot(w, gD + r, c=plt.get_cmap("jet")(f), zorder=-r)

            # timer.start()
            # plt.show()

            # gDOS_copy = gDOS.copy()
            # gDOS_copy[gDOS_copy == 0] = np.nan

            # fig = plt.figure()
            # timer = fig.canvas.new_timer(interval=30000)
            # timer.add_callback(plt.close)

            # plt.imshow(np.flipud(gDOS_copy), aspect="auto", vmax=100)
            # plt.xticks([])
            # plt.yticks([])
            # plt.xlabel("$\\omega/\\omega_{max}$")
            # plt.ylabel("$\\phi$")

            # timer.start()
            # plt.show()\
        except KeyboardInterrupt:
            np.savez(superjob.fn(pdos_name), **pdos_dict_raw)
            break


if __name__ == "__main__":
    import sys

    assert len(sys.argv) == 2
    ojob = project.open_job(id=sys.argv[1])

    make_pdos(ojob)
